Xét trường hợp khó nhất -- SRTN, các trường hợp dễ hơn xử lí còn dễ hơn nên ko nói: hiển nhiên khi một tiến trình mới xuất hiện thì phải ưu tiên nó rồi, và nếu có nhiều tiến trình MỚI cùng lúc xuất hiện thì cái nào có arrival trễ hơn được ưu tiên (luật ưu tiên cái mới). Từ khúc này về sau ta không quan tâm các tiến trình mới xuất hiện mà chỉ quan tâm đến tranh chấp giữa các tiến trình trong nội bộ (các) CPU, R

ta đặt vấn đề phức tạp (tổng quát) hơn:
giả sử có nhiều R, nhiều CPU:
- có m tiến trình từ m CPU được add vào ready queue (hết timeslice hoặc bị force dừng) cùng một lúc 
- có n tiến trình từ n R được add vào ready queue (tức từ I/O đẩy lên) cùng một lúc
Vấn đề: Tất cả chúng đang tranh chấp, ưu tiên cái nào?

Cách xử lí:
-> lý thuyết: ưu tiên cái nào mà thời-điểm-cuối-cùng-ra-khỏi-CPU sớm nhất đi vào. Lúc này m tiến trình từ CPU được add vào CPU cùng một lúc do hết timeslice sẽ có thời điểm cuối cùng ra khỏi CPU = nhau (cùng một thời điểm hết timeslice hoặc bị force dừng và cũng ngay sau đó chúng đều gửi yêu cầu vào ready queue) thì ưu tiên cái nào cũng được
(việc ưu tiên cái nào cũng được như này có thể khiến cho thời gian turnaround time hay waiting của các tiến trình ở mỗi tổ hợp là khác nhau, do đó cân nhắc kĩ điều này. Tuy nhiên nếu có điều kiện gì bổ sung giữa các tiến trình hết timeslice cùng một lúc như vầy thì bổ sung thêm đơn giản ấy mà)

code => có thể tạo hashmap "unordered_map<Process*, int> last_out_cpu_time" với tham số int là để lưu thời gian tiến trình ra khỏi CPU, còn tham số còn lại là lưu con trỏ tiến trình
tức cứ mỗi loop while, trong quá trình chạy, khi tiến trình nào ra khỏi CPU (CPU_usage_time = 0 hoặc hết time_slice hoặc bị force dừng) thì insert tiến trình đó và thời điểm hiện tại ngay vào "unordered_map<Process*, int> last_out_cpu_time"

tua lên đầu mỗi loop while, nếu có tiến trình nào gửi yêu cầu vào ready queue thì tìm kết quả tiến trình đó trong map "last_out_cpu_time" rồi add vào "vector<pair<Process*, int>> priority, sort vector priority theo thời gian sớm nhất ra khỏi CPU (tức thứ tự thời gian tăng dần), từ đó phần tử đầu tiên là tiến trình ra khỏi CPU sớm nhất (tính dùng priority_queue cho cái này nhưng nghĩ kĩ lại thì độ phức tạp ngang nhau sau khi add/push vào hết các phần tử thôi, đều là O(N.log(N))). Duyệt vector, add các priority[i].first vào CPU_queue (ready queue)
====================================================
====================================================
1 
4
0 5 3 2 4
2 7 6 9
3 3 2 1
5 5 1 3

// FCFS chỉ có thể conflict ready queue tối đa 2 cái: cái xuất hiện mới (2), cái từ I/O đẩy qua (1)
// conflict 2 cái giây thứ 6

input:
1
3
0 1 5 1
3 3
6 2
output:
1 _ _ 2 2 2 3 3 1 
_ 1 1 1 1 1 
9 3 2 
2 0 0 



// RR chỉ có thể conflict tối đa 3 cái: cái xuất hiện mới (3), cái đẩy từ I/O qua (2), cái hết hạn time slice (1)
// nguyên nhân có priority trên: cái nào mà lần cuối sử dụng CPU càng sớm, thì khi add vào ready queue tính là càng mới
// conflict 3 cái giây thứ 6

input:
2
3
3
0 1 5 4
3 7 3
6 3 3
output:
1 _ _ 2 2 2 3 3 3 1 1 1 2 2 2 1 2 
_ 1 1 1 1 1 _ _ _ 3 3 3 _ _ _ _ _ 2 2 2 
16 17 6 
6 7 0 


// chung cho SJF và SRTN: trong trường hợp có 2 tiến trình với prority = nhau được push vào ready queue (hiển nhiên là vào 2 thời điểm khác nhau, nếu bằng nhau thì lấy cái nào cũng được) (điều này chỉ có thể xảy ra khi chúng đều là tiến trình mới xuất hiện), theo quy tắc ưu tiên thời gian thì tiến trình nào được push vào sau thì được ưu tiên dequeue trước, ta sẽ cần cài đặt thêm biến time.priority cho struct
// SJF có thể conflict tối đa N cái: (CÁC) cái xuất hiện mới (2), cái đẩy từ I/O qua (1)
input:
3
3
0 1 5 4
3 7 3
6 3 3
output:
1 _ _ 2 2 2 2 2 2 2 3 3 3 1 1 1 1 
_ 1 1 1 1 1 _ _ _ _ 2 2 2 3 3 3 
17 10 10 
7 0 4 

input:
3
4
0 7
2 4
4 1
5 4
output:
1 1 1 1 1 1 1 3 4 4 4 4 2 2 2 2 

7 14 4 7 
0 10 3 3 


// SRTN như trên, có thể conflict tối đa N cái: (CÁC) cái xuất hiện mới (3), cái đẩy từ I/O qua (2), cái hiện tại bị interupt và đẩy vào ready queue (1)
input:
4
3
0 1 5 2
3 5
6 2
output:
1 _ _ 2 2 2 3 3 1 1 2 2 
_ 1 1 1 1 1 
10 9 2 
2 4 0 
