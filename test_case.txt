Quy tắc ưu tiên cái mới trong mọi thuật toán hoạt động như sau:
- khi đẩy tiến trình vào ready queue nếu xảy ra conflict thì tiến trình nào có last_out_CPU_time sớm hơn thì được ưu tiên dequeue ra trước (last_out_CPU_time mặc định của 1 tiến trình khi MỚI ĐƯỢC ADD VÀO ta quy ước là 0 -- tức sớm nhất, mục đích khiến nó giành được quyền ưu tiên dequeue nhất). Giải thích: last_out_CPU_time sớm nhất tức là lần cuối nó sử dụng CPU là quá lâu trước đó, do đó khi vào lại thì nó giống như một người mới nhất vậy
- trong trường hợp có 2 tiến trình mới xuất hiện được push vào ready queue (hiển nhiên là vào 2 thời điểm khác nhau, nếu bằng nhau thì lấy cái nào cũng được) sẽ có last_out_CPU_time đều = 0, tiến trình nào được push vào SAU (mới hơn) thì được ưu tiên dequeue trước
=====================================================
=====================================================

Xét trường hợp khó nhất -- SRTN, các trường hợp dễ hơn xử lí còn dễ hơn nên ko nói: hiển nhiên khi một tiến trình mới xuất hiện thì phải ưu tiên nó rồi, và nếu có nhiều tiến trình MỚI cùng lúc xuất hiện thì cái nào có arrival trễ hơn được ưu tiên (luật ưu tiên cái mới). Từ khúc này về sau ta không quan tâm các tiến trình mới xuất hiện mà chỉ quan tâm đến tranh chấp giữa các tiến trình trong nội bộ (các) CPU, R

ta đặt vấn đề phức tạp (tổng quát) hơn:
giả sử có nhiều R nhưng chỉ có 1 CPU và có N tiến trình từ N cái R được add vào ready queue (tức từ I/O đẩy lên) cùng một lúc, + thêm trường hợp xấu nhất luôn tức một tiến trình hết timeslice trong CPU (hoặc bị force dừng) cũng gửi yêu cầu vào ready queue
Vấn đề: Tất cả chúng đang tranh chấp, ưu tiên cái nào?

Cách xử lí:
-> lý thuyết: ưu tiên cái nào mà thời-điểm-cuối-cùng-ra-khỏi-CPU sớm nhất đi vào (luật ưu tiên cái cũ), tuy nhiên nếu có P tiến trình có thời-điểm-cuối-cùng-ra-khỏi-CPU = nhau thì cũng ưu tiên cái nào trước cũng được.
nói thêm: do chỉ có một CPU nên khi một tiến trình trong CPU bị hết timeslice hoặc bị force dừng thì thời-điểm-cuối-cùng-ra-khỏi-CPU của nó cùng vói thời điểm gửi tín hiệu vào ready queue (trễ nhất luôn rồi) nên hiển nhiên nó sẽ bị ưu tiên sau cùng so với tất cả các tiến trình từ I/O qua

(việc ưu tiên cái nào cũng được như này có thể khiến cho turnaround time hay waiting time của các tiến trình ở mỗi tổ hợp là khác nhau, do đó cân nhắc kĩ điều này. Tuy nhiên nếu có điều kiện gì bổ sung giữa các tiến trình có thời-điểm-cuối-cùng-ra-khỏi-CPU = nhau như vầy thì bổ sung thêm đơn giản ấy mà)

code => có thể tạo hashmap "unordered_map<Process*, int> last_out_cpu_time" với tham số int là để lưu thời-điểm-cuối-cùng-ra-khỏi-CPU của tiến trình, còn tham số còn lại là lưu con trỏ tiến trình
tức cứ mỗi loop while, trong quá trình chạy, khi tiến trình nào ra khỏi CPU (CPU_usage_time = 0 hoặc hết time_slice hoặc bị force dừng) thì insert tiến trình đó và thời điểm hiện tại ngay vào "unordered_map<Process*, int> last_out_cpu_time"

tua lên đầu mỗi loop while, add các tiến trình vào "priority_queue<Process*, vector<Process*>, time_comparator> CPU_queue" theo thời-điểm-cuối-cùng-ra-khỏi-CPU sớm nhất (tức thứ tự thời gian tăng dần), từ đó phần tử đầu tiên khi lấy ra sẽ luôn là tiến trình ra khỏi CPU sớm nhất. (mỗi bước add như vậy chỉ có độ phức tạp log(N))
====================================================
====================================================

// FCFS chỉ có thể conflict ready queue tối đa 2 cái: cái xuất hiện mới (2), cái từ I/O đẩy qua (1)
// conflict 2 cái giây thứ 6

input:
1
3
0 1 5 1
3 3
6 2
output:
1 _ _ 2 2 2 3 3 1 
_ 1 1 1 1 1 
9 3 2 
2 0 0 



// RR chỉ có thể conflict tối đa 3 cái: cái xuất hiện mới (3), cái đẩy từ I/O qua (2), cái hết hạn time slice (1)
// nguyên nhân có priority trên: cái nào mà lần cuối sử dụng CPU càng sớm, thì khi add vào ready queue tính là càng mới
// conflict 3 cái giây thứ 6

input:
2
3
3
0 1 5 4
3 7 3
6 3 3
output:
1 _ _ 2 2 2 3 3 3 1 1 1 2 2 2 1 2 
_ 1 1 1 1 1 _ _ _ 3 3 3 _ _ _ _ _ 2 2 2 
16 17 6 
6 7 0 




// SJF có thể conflict tối đa N cái: (CÁC) cái xuất hiện mới (2), 1 cái đẩy từ I/O qua (1)
ví dụ tranh chấp 2 cái từ I/O sang tại giây 8
input:
3
4
0 4 3 2
5 1
6 1 1 2
7 1
output:
1 1 1 1 _ 2 3 4 1 1 3 3 
_ _ _ _ 1 1 1 3 
10 1 6 1 
1 0 2 0 

ví dụ tranh chấp 2 cái mới xuất hiện tại giây 6
+ tranh chấp 2 cái từ I/O sang tại giây 12
input:
3
4
0 1 5 5
3 3
6 3 3 5
5 3
output:
1 _ _ 2 2 2 3 3 3 4 4 4 1 1 1 1 1 3 3 3 3 3 
_ 1 1 1 1 1 _ _ _ 3 3 3 
17 3 16 7 
6 0 5 4 

tranh chấp 2 cái mới xuất hiện tại giây 8
input:
3
4
0 7
2 4
4 1
5 4
output:
1 1 1 1 1 1 1 3 4 4 4 4 2 2 2 2 

7 14 4 7 
0 10 3 3 


// SRTN như trên, có thể conflict tối đa N cái: (CÁC) cái xuất hiện mới (3), 1 cái đẩy từ I/O qua (2), 1 cái hiện tại bị interupt và đẩy vào ready queue (1)
ví dụ tranh chấp 3 cái tại giây 6: 1 cái mới xuất hiện, 1 cái đẩy từ I/O qua, 1 cái hiện tại bị interupt và đẩy vào ready queue
input:
4
3
0 1 5 2
3 5
6 2
output:
1 _ _ 2 2 2 3 3 1 1 2 2 
_ 1 1 1 1 1 
10 9 2 
2 4 0 

ví dụ tranh chấp 3 cái ở giây 6: 2 cái mới add vào, cái từ I/O đẩy qua
+ tranh chấp 2 cái từ I/O qua ở giây 12
input:
4
4
0 4 2 3
4 2
4 3
6 3 3 3
output:
1 1 1 1 2 2 4 4 4 3 3 3 1 1 1 4 4 4 
_ _ _ _ 1 1 _ _ _ 4 4 4 
15 2 8 12 
6 0 5 3 
